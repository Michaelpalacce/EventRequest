
# [Error Handling | ErrorHandler](#error-handling-errorHandler)
- The EventRequest has a default ErrorHandler set in it
- It is a good idea to instantiate a new ErrorHandler OUTSIDE the eventRequest for speed. You can attach a preconfigured ErrorHandler rather than configuring the one created every request.
- The Error Handler supports error namespaces. An error namespace is a string error code, that is separated by dots: `app.module.someError`. Every Dot represents a new Error namespace. They may take a second to get the hang on but are a powerful tool when you understand them better!
- Error Handling in the framework is done entirely using error codes.
- Every Error Code thrown in the app will be in the following namespace: `app.er`
- This class can be extended and custom functionality may be written
- Alternatively instead of extending you can write your own class as long as it has a handleError function.
- You can write your own ErrorHandler, but since there are errors generated by the framework, they will always look for an ErrorHandler with a handleError function and if one is not present, will create a new one.

#### How are Errors processed
- In the framework in the case of a synchronous middleware, all errors thrown will be processed and formatted into an error with a code and a message
- By default errors will be logged to the console, and you can disable this by specifying a custom error handler or adding a general namespace to the ErrorHandler that will catch errors and you can use to process in any way you see fit ( see further down for more info )
- In the case of an errorCallback, you can always pass event.next as the argument ( it will be triggered if the first argument is !== false )
~~~javascript 
app.get( '/', ( event ) => {
    const someFunc = ( variableOne, variableTwo, errorCallback ) => {
        errorCallback( variableOne === variableTwo );
    }
    
    someFunc( 1, 1, event.next );
} );
~~~

- In the case of an async function, if you want your error to be automatically processed, you can return the promise
~~~javascript 
app.get( '/', async ( event ) =>{
    const variables	= { test: 'TEST!!', hello: 'HELLO WORLD!!'};

    return event.render( 'test', variables ); // If this fails, this will be automatically handled by the framework
});
~~~

- You could also add event.next in the .catch()
~~~javascript 
app.get( '/', async ( event ) =>{
    const variables	= { test: 'TEST!!', hello: 'HELLO WORLD!!'};

    event.render( 'test', variables ).catch( event.next ); // If this fails, this will be automatically handled by the framework
});
~~~

***
#### Accepted Options:

**NONE**

***
#### Events:

**on_error: ( mixed error )**
- This is called by the default error handler in case of an error

***
#### Functions:

**async handleError( EventRequest event, * errorToHandle = null, Number errStatusCode = null, emitError = null ): Promise: void**
- This function is **ASYNCHRONOUS**
- This function will call a callback of either the default Namespace or of a custom one, with parameters: { event, code, status, message, error, headers, emit, formatter }
- Note The callback uses destructing: `callback( { event, code, status, message, error, headers, emit, formatter } )` so if you write your own custom callback for a  namespace make sure it takes this into account. For example: `_defaultCase( { event, code, status, error, message, headers, emit, formatter } )`. You can get as many parameters as you need and ignore the rest( or not even define them )
- Check Namespaces section for more information how these parameters will be generated!

**addNamespace( errorCode, { message, callback, status, emit, headers, formatter } = {} ): void**
- Adds a new namespace, given an errorCode and an object containing one or more parameters
- Note that the namespaceOptions use Object destructing, so if you want to call it it must be in the following format:
~~~javascript
errorHandler.addNamespace( 'app.test.namespace', { message: 'I am a message', emit: false, headers: { headerOne: 2 }, callback: () => {}, formatter: () => {} } );
~~~
- Any parameters that are not provided will be taken from the defaultNamespace ( check Namespaces section for more info )

***
#### Attached Functionality:

**event.errorHandler: ErrorHandler**
- Attached by default to the EventRequest but can be overwritten at any point


#### Errors thrown in the framework:
- They all start with `app.er`
- In general they do not have any messages attached to them with some few exceptions

**app.er.timeout.timedOut**
- Thrown by the Timeout Plugin with a status of 408
- { code: 'app.er.timeout.timedOut', status: 408 }

**app.er.er_etag.invalid.payload**
- Thrown by the Etag Plugin when the payload is not a String, Buffer or fs.Stats

**app.er.staticResources.fileNotFound**
- { code: 'app.er.staticResources.fileNotFound', message: `File not found: ${item}`, status: 404 }
- Thrown by the Timeout Plugin with a status of 408

**app.er.bodyParser.invalidParser**
- Thrown by the body parser handler when an invalid parser was attempted to be added

**app.er.logger.invalidUniqueId**
- Thrown by loggers if invalid uniqueId was passed ( not string )

**app.er.bodyParser.multipart.invalidState**, **app.er.bodyParser.multipart.invalidMetadata**, **app.er.bodyParser.multipart.couldNotFlushBuffer**
- Thrown by lhe multipart data parser if a critical error was detected when parsing the multipart body

**app.er.pluginManager.invalidPlugin**
- Thrown by the plugin manager when an invalid plugin was attempted to be added

**app.er.pluginManager.pluginDoesNotExist**
- Thrown by the plugin manager if a plugin that does not exist was attempted to be retrieved

**app.er.rateLimits.connection_delay.missingDelayTimeOrDelayRetries**
- Thrown by the rate limits plugin if an invalid connection delay policy rule was added

**app.er.rateLimits.invalidOptions**
- Thrown by the rate limits plugin if an invalid rule was added

**app.er.rateLimits.tooManyRequests**
- Thrown by the rate limits plugin if rate limiting ocurred
- { code: 'app.er.rateLimits.tooManyRequests', status: TOO_MANY_REQUESTS_STATUS_CODE, headers: { 'Retry-After': retryAfterTime }

**app.er.routing.invalidMiddlewareAdded**
- Thrown by the routing when an invalid middleware was added

**app.er.routing.cannotDefineMiddleware**
- Thrown by the routing when an invalid global middleware was attempted to be defined

**app.er.bodyParser.form.notSupported**
- Thrown by the form body parser when the body to be parsed is not supported

**app.er.bodyParser.multipart.wrongHeaderData**
- Thrown by the multipart body parser when there is wrong or missing header data. Either `content-type` or `content-length`. `content-type` may not have the boundry defined

**app.er.bodyParser.multipart.maxPayloadReached**
- Thrown by the multipart body parser when the maxPayload is not infinite ( not 0 ) and the maxPayload and `content-length` do not match

**app.er.bodyParser.json.notSupported**
- Thrown by the json body parser when the body to be parsed is not supported

**app.er.routing.missingMiddleware**
- Thrown by the routing when a middleware was missing when adding two routers together
- throw { code: 'app.er.routing.missingMiddleware', message: middleware };

**app.er.server.missingPluginDependency.${pluginId}**
- Thrown by the server when a plugin has a missing dependency. The pluginId will be attached at the end

**app.er.server.missingPlugin.${id}**
- Thrown by the server when a plugin is missing. The pluginId will be attached at the end

**app.er.session.missingDataServer**
- Thrown by the session when the event request is missing a dataServer

**app.er.session.couldNotSaveSessionToDataServer**
- Thrown by the session when the session is attempted to be saved to the data server but an error is returned

**app.err.templatingEngine.errorRendering**
- Thrown by when there was an error during rendering in the templating engine plugin

**app.er.logging.transport.file.fileLogPathNotProvided**
- Thrown by the file transport if there is no filePath provided

**app.er.validation.error**
- Thrown by the validation plugin when there is an error with validation. Could be that the EventRequest has a missing property or validation of input failed
- { status: 400, code: 'app.er.validation.error', message: { [validationParameter]: validationResult.getValidationResult() } }
- { status: 400, code: 'app.er.validation.error', message: `Could not validate ${toValidate} as it is not a property of the EventRequest` }

***
***
#### [Custom Error Handler:](#custom-error-handler)
- You can specify a custom error handler very easily:
~~~javascript
event.errorHandler = {
    handleError: () => {
        event.send( 'Custom Error Handling' )
    }
}
~~~~

***
***
#### [Namespaces:](#error-handling-namespaces)
- Error Namespaces are ways for you to attach common error handling to the same section of your application. If you have the following namespaces: `app.security.invalid.password`, `app.security.invalid.username`, `app.security.unauthorized`, `app.security.invalid.token` and lets say that everything besides `app.security.invalid.token` has been handled, what do we do with that one specifically? Well, if you attach a namespace that is `app.security` with a message of 'General Security Error' and a status of 401 or 403, then you don't have to worry that you have not handled this scenario.
- Adding a namespace is done by: `errorHandler.addNamespace( 'code' {...} );`

~~~javscript
const ErrorHandler    = require( 'event_request/server/components/error/error_handler' );
const handler    = new ErrorHandler();

handler.defaultNamespace.callback    = function()
{
    console.log( arguments );
}

handler.addNamespace( 'app.security', { message: 'General Security Error', status: 403 } );
handler.addNamespace( 'app.security.invalid.password', { message: 'Your password is not valid', status: 403 } );
handler.addNamespace( 'app.security.invalid.username', { message: 'Your username is not valid', status: 403 } );
handler.addNamespace( 'app.security.unauthorized', { message: 'You are not authorized for this request', status: 401 } );

// This will set the error code to `app.security.invalid.token` 
// so you know EXACTLY what the error is but the message and status will be taken from app.security namespace
handler.handleError( {}, 'app.security.invalid.token' );
~~~

- Error Namespaces allow for a LOT of customization ( and anything not customized, will be taken from the defaultNamespace ). When adding a namespace you can specify:
    - message - what message the user will see
    - status - This will be the status code that will be sent to the user
    - callback - Function that will be called with `{ event, code, status, message, error, headers, emit, formatter }`. You can use any of these parameters. You don't need to define them all if they are unused. This function can also be async.
    - emit - Flag whether an on_error event should be emitted. Note: this is actually done in the callback, so its entirely in your own control if you want to stop it
    - headers - A JS Object that will be put through a for...in loop. Every key will be set as a header and every value as the respective header value.  Note: this is actually done in the callback, so its entirely in your own control if you want to stop it
    - formatter - This function will be called by the default callback at the end, to format the way the response will be sent. This way you can customize only the response if you so wish to ( for example you want to send html in one case and json in another ). The formatter accepts all the arguments of callback without the formatter argument. This function can also be async.

This is the default Namespace callback:
~~~javascript
/**
     * @brief    Fallback namespace that will be called whenever there is no namespace for the given error code OR the namespace match does not have a callback
     *
     * @details    This callback will set any headers provided
     *             This callback will set the status code given
     *             This callback will format an appropriate message in case of an error
     *             This callback emit an error IF needed
     *
     * @param    {EventRequest} event
     * @param    {String} errorCode
     * @param    {Number} status
     * @param    {*} error
     * @param    {*} message
     * @param    {Object} headers
     * @param    {Boolean} emit
     * @param    {Function} formatter
     *
     * @private
     *
     * @return	void
     */
    async _defaultCase( { event, code, status, error, message, headers, emit, formatter } )
    {
        if ( event.isFinished() )
            return;
        
        const toEmit = { code, status, headers };
        
        if ( message !== null && message !== undefined )
            toEmit.message = message;
        
        if ( error !== null && error !== undefined )
            toEmit.error = error;
        
        if ( emit )
            event.emit( 'on_error', toEmit );
        
        for ( const key in headers )
        {
            if ( ! {}.hasOwnProperty.call( headers, key ) )
                continue;
        
            event.setResponseHeader( key, headers[key] );
        }

       const result	= formatter( { event, code, status, error, message, headers, emit } );
       
      if ( result instanceof Promise )
            event.send( await result, status );
      else
            event.send( result, status );
    }
~~~

- If you ever want to send an error you can do this by simply throwing an Error with the namespace as the only message
- If you want to include more information you can also just throw an object or a string!
- As long as they are thrown in a middleware somewhere or a promise is rejected with them, they will be picked up by the ErrorHandling and handled appropriately. Note: Promise rejections will only be picked up using the async await approach. It is recomended if you want to error handle a `.catch()` you use `.catch( event.next )`

~~~javscript
throw new Error( 'app.test.namespace' );

throw 'app.test.namespace';

throw { code: 'app.test.namespace', status: 500 };
~~~

- handleError will handle a wide variety of information.
- **You can pass any parameter that you would pass when adding a namespace to the errorToHandle and they will overwrite the namespace ones**
- **It is preffered that you pass your own object with the parameters like this: `{ code: 'app.test', status: 500, message: 'User Message', error: new Error( 'Error To Log' ), headers: { headerOne: 'value' }, emit: false };`. Note that if status code is omitted, the status code passed to handleError will be taken, if not the status code form the namespace defined by the code will be used. Same logic applies for emit. If message or headers are not passed, they will be taken from the namespace.**
- The errorToHandle can by anything from a simple string, Error, object and others.
- If the errorToHandle is a string and it matches the pattern of a namespace, then it will be treated as a namespace
- If the errorToHandle is an Error and Error.message matches the pattern of a namespace, then Error.message will be treated as a namespace
- The logic of what will be emitted and what will be sent to the user is really complex. Below there is an example. Play around, comment out some lines, write new cases to see what happens

***
#### Example:

~~~javascript
const ErrorHandler = require( 'event_request/server/components/error/error_handler' );
const app = require( 'event_request' )();

const errorHandler  = new ErrorHandler();

errorHandler.addNamespace( 'test.formatter.formatted.message', { formatter: ( { code } ) => { return code.toUpperCase() } } );
errorHandler.addNamespace( 'test.formatter.formatted.async.message', { formatter: async ( { code } ) => { return code.toUpperCase() } } );
errorHandler.addNamespace( 'test.exists.with.just.message', { message: 'Default Message' } );
errorHandler.addNamespace( 'test.exists.with.message.and.status', { status: 532, message: 'Message with Status' } );
errorHandler.addNamespace( 'test.exists.with.status', { status: 462 } );
errorHandler.addNamespace( 'test.deep', { status: 532, message: 'DEEP message', emit: false, headers: { headerOne: 1, headerTwo: 2 } } );

errorHandler.addNamespace(
	'test.callback',
	{
		callback: ( { event, code, status, message, error, headers, emit } ) => {
			if ( emit )
				event.emit( 'on_error', { event, code, status, message, error, headers, emit } );

			event.send( message, status );
		},
		status: 532,
		message: 'CALLBACK MESSAGE',
		emit: false,
		headers: { headerOne: 1, headerTwo: 2 }
	}
);

app.add( ( event ) => {
	event.errorHandler    = errorHandler;
	event.next();
});

app.add(( event ) => {
	event.on( 'on_error', function()
		{
			console.log( arguments );
		}
	);

	throw new Error( 'test.formatter.formatted.message' ); //This message will be formatted

	event.sendError( 'test.formatter.formatted.async.message' ); //This message will be formatted, but more importantly IF there is something after it, it may result in an error. This will be done ASYNCHRONOUSLY

	throw new Error( 'Some random error!' ); // No problem if the error is not a namespace! It will go to the default namespace
	throw 'Some Error!'; // No problem if the error is not a namespace! It will go to the default namespace
	throw { code: 'test.exists.with.just.message', status: 200, headers: { headerOne: 'value' }, emit: true }; // If you need that fine control!

	event.sendError( 'test.callback', 500 ); // This will call the error Handler 'test.callback'
	event.sendError( 'test.exists.with.just.message', 500 ); // This will call the error Handler 'test.exists.with.just.message'
	event.sendError( 'test.exists.with.message.and.status' ); // This will call the error Handler 'test.exists.with.message.and.status'
	event.sendError( 'test.exists.with.status' ); // This will call the error Handler 'test.exists.with.status'
	event.sendError( 'test.deep.we.go.on.deeper' ); // This will call the error Handler 'test.deep'

	event.next( 'test.callback', 500 ); // This will call the error Handler 'test.callback'
	event.next( 'test.exists.with.just.message', 500 ); // This will call the error Handler 'test.exists.with.just.message'
	event.next( 'test.exists.with.message.and.status' ); // This will call the error Handler 'test.exists.with.message.and.status'
	event.next( 'test.exists.with.status' ); // This will call the error Handler 'test.exists.with.status'
	event.next( 'test.deep.we.go.on.deeper' ); // This will call the error Handler 'test.deep'

	event.next( new Error( 'test.callback' ), 500 ); // This will call the error Handler 'test.callback'
	event.next( new Error( 'test.exists.with.just.message' ), 500 ); // This will call the error Handler 'test.exists.with.just.message'
	event.next( new Error( 'test.exists.with.message.and.status' ) ); // This will call the error Handler 'test.exists.with.message.and.status'
	event.next( new Error( 'test.exists.with.status' ) ); // This will call the error Handler 'test.exists.with.status'
	event.next( new Error( 'test.deep.we.go.on.deeper' ) ); // This will call the error Handler 'test.deep'

	event.next( { code: 'test.callback' }, 500 ); // This will call the error Handler 'test.callback'
	event.next( { code: 'test.exists.with.just.message' }, 500 ); // This will call the error Handler 'test.exists.with.just.message'
	event.next( { code: 'test.exists.with.message.and.status', status: 502 }, 503 ); // This will call the error Handler 'test.exists.with.message.and.status'
	event.next( { code: 'test.exists.with.message.and.status', error: new Error( 'test.error' ) }, 503 ); // This will call the error Handler 'test.exists.with.message.and.status'
	event.next( { code: 'test.exists.with.message.and.status', error: 'test.error' }, 503 ); // This will call the error Handler 'test.exists.with.message.and.status'
	event.next( { code: 'test.exists.with.message.and.status', error: 'test.error', message: 'test.MESSAGE' }, 503 ); // This will call the error Handler 'test.exists.with.message.and.status'
	event.next( { code: 'test.exists.with.status' } ); // This will call the error Handler 'test.exists.with.status'
	event.next( { code: 'test.deep.we.go.on.deeper' } ); // This will call the error Handler 'test.deep'

	event.next( 'Error', 500 ); // This will call the error Handler default namespace

	event.send( 'Error', 500 ); // This will !!NOT!! call the error Handler

	throw new Error( 'test.exists.with.message.and.status' );
});
app.listen( 80 );
~~~

***
***
***
